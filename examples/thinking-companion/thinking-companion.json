{
    "Comment": "Minimal Thinking Companion PoC - Outer/Inner Voice with Stance Signal",
    "StartAt": "CreatePromptDictionary",
    "States": {
        "CreatePromptDictionary": {
            "Type": "Pass",
            "Parameters": {
                "outer.logic.assumption": "Focus diagnostic energy on assumption tracing. Surface what's taken as given without examination.",
                "outer.logic.implication": "Trace logical consequences methodically. What follows if this holds? What are the second-order effects?",
                "outer.logic.missing-data": "Identify information gaps precisely. What evidence is needed to evaluate this claim?",
                "outer.stance.overreach": "Exercise heightened epistemic humility. Test claim boundaries aggressively. Resist overconfident assertions.",
                "outer.stance.uncertainty": "Acknowledge unknowns explicitly. Use 'I don't know' when appropriate. Distinguish data from inference.",
                "outer.stance.speculation": "Distinguish clearly between data, inference, and speculation. Mark exploratory reasoning as such.",
                "outer.rhythm.stalling": "Use brevity to create movement. Focus on one core diagnostic question. Consider strike-claim readiness.",
                "outer.rhythm.cognitive-load": "Reduce complexity. Break down into simpler diagnostic components. Use clearer structure.",
                "outer.rhythm.pacing": "Match the user's information processing speed. Adjust depth accordingly.",
                "outer.rhythm.flow": "Support smooth progression. Build on previous insights without repetition.",
                "outer.affect.witness-call": "Provide spacious acknowledgment first. Validate without rushing to diagnostic work.",
                "outer.affect.valence": "Attune to emotional tone while maintaining diagnostic rigor. Adjust intensity appropriately.",
                "outer.affect.relational-mode": "Calibrate engagement style to relational needs while preserving epistemic stance.",
                "outer.framing.frame": "Examine conceptual boundaries. What worldview or lens is operating here? What's included/excluded?",
                "outer.framing.tension": "Surface competing forces explicitly. Hold paradox without premature resolution.",
                "outer.framing.container": "Create safe space for vulnerable exploration while maintaining diagnostic precision.",
                "outer.meta.mode-drift": "Recalibrate to diagnostic stance immediately. Return to assumption-exposing, claim-testing positioning.",
                "outer.meta.alignment-gap": "Address mismatch between stated intent and execution. Surface the disconnect.",
                "outer.meta.trigger-match": "Recognize sensitive terrain. Proceed with diagnostic work while respecting the stakes.",
                "inner.logic.assumption": "What foundational assumption is invisible here? What's being taken as obviously true?",
                "inner.logic.implication": "What consequences are being ignored? What follows that hasn't been considered?",
                "inner.logic.missing-data": "What crucial information is absent? What questions aren't being asked?",
                "inner.stance.overreach": "What claims exceed the available evidence? Where is certainty masking uncertainty?",
                "inner.stance.uncertainty": "What unknowns are being glossed over? Where should doubt be more explicit?",
                "inner.stance.speculation": "What's being presented as fact that's actually inference or speculation?",
                "inner.rhythm.stalling": "Is this diagnostic work moving toward insight or cycling in place? Are we avoiding something?",
                "inner.rhythm.cognitive-load": "Is the complexity serving clarity or creating confusion? What's essential vs. elaborate?",
                "inner.rhythm.pacing": "Is the rhythm matching the user's capacity or pushing beyond it?",
                "inner.rhythm.flow": "Are we building coherently or jumping between disconnected observations?",
                "inner.affect.witness-call": "What emotional need is present but unaddressed? What requires acknowledgment before analysis?",
                "inner.affect.valence": "What emotional reality is being excluded from this frame? What feeling is being avoided?",
                "inner.affect.relational-mode": "How is the relational dynamic affecting the inquiry? What's the underlying connection need?",
                "inner.framing.frame": "What perspectives are excluded from this worldview? Who or what is rendered invisible?",
                "inner.framing.tension": "What opposing forces are being overlooked? What contradiction is being smoothed over?",
                "inner.framing.container": "What vulnerability or risk is this safe space meant to hold? What's the underlying need?",
                "inner.meta.mode-drift": "Are we maintaining diagnostic rigor or slipping into pleasing? Where's the epistemic edge?",
                "inner.meta.alignment-gap": "What's the disconnect between espoused values and actual behavior in this response?",
                "inner.meta.trigger-match": "What sensitive element requires more careful attention? What's at stake that we're not naming?",
                "adaptation.cognitive-load": "Use shorter, clearer responses. Break complex ideas into digestible pieces.",
                "adaptation.stalling": "Be brief and direct. Create space for movement rather than filling it with analysis.",
                "adaptation.pacing": "Match the user's information processing rhythm.",
                "adaptation.flow": "Support natural progression without forcing artificial structure.",
                "adaptation.witness-call": "Allow space for acknowledgment and validation. Don't rush to problem-solving.",
                "adaptation.uncertainty": "Be comfortable with 'I don't know' and partial answers. Resist false certainty."
            },
            "ResultPath": "$.prompts",
            "Next": "ReceiveUserInput"
        },
        "ReceiveUserInput": {
            "Type": "Task",
            "Resource": "appendUserMessage",
            "Parameters": {
                "thread.$": "$.thread",
                "message": {
                    "role": "user",
                    "content.$": "$.user_input"
                }
            },
            "ResultPath": "$.thread",
            "Next": "SignalDistillers"
        },
        "SignalDistillers": {
            "Type": "Parallel",
            "Branches": [
                {
                    "StartAt": "LogicDistiller",
                    "States": {
                        "LogicDistiller": {
                            "Type": "Task",
                            "Resource": "callLLM",
                            "Parameters": {
                                "provider": "openai",
                                "model": "gpt-4o-mini",
                                "temperature": 0,
                                "max_tokens": 50,
                                "response_format": {
                                    "type": "json_object"
                                },
                                "prompt.$": "States.Format('Analyze the user input for logic signals. Detect any of: assumption (unstated assumptions or premises), implication (logical consequences or follow-through), missing-data (information gaps or needed evidence). Return JSON like {{\"signals\": [\"assumption\", \"implication\"]}} or {{\"signals\": []}} if none detected. Use only the exact signal names provided. User input: \"{}\"', $.user_input)"
                            },
                            "Retry": [
                                {
                                    "ErrorEquals": [
                                        "States.ALL"
                                    ],
                                    "IntervalSeconds": 1,
                                    "MaxAttempts": 2,
                                    "BackoffRate": 2.0
                                }
                            ],
                            "Catch": [
                                {
                                    "ErrorEquals": [
                                        "States.ALL"
                                    ],
                                    "Next": "FallbackLogicDistiller",
                                    "ResultPath": "$.error"
                                }
                            ],
                            "Next": "EndLogicBranch"
                        },
                        "FallbackLogicDistiller": {
                            "Type": "Pass",
                            "Parameters": {
                                "content": "{\"signals\": []}"
                            },
                            "Next": "EndLogicBranch"
                        },
                        "EndLogicBranch": {
                            "Type": "Pass",
                            "End": true
                        }
                    }
                },
                {
                    "StartAt": "StanceDistiller",
                    "States": {
                        "StanceDistiller": {
                            "Type": "Task",
                            "Resource": "callLLM",
                            "Parameters": {
                                "provider": "openai",
                                "model": "gpt-4o-mini",
                                "temperature": 0,
                                "max_tokens": 50,
                                "response_format": {
                                    "type": "json_object"
                                },
                                "prompt.$": "States.Format('Analyze the user input for stance signals. Detect any of: overreach (claims beyond available evidence), uncertainty (acknowledging unknowns or limits), speculation (hypothetical or exploratory reasoning). Return JSON like {{\"signals\": [\"uncertainty\"]}} or {{\"signals\": []}} if none detected. Use only the exact signal names provided. User input: \"{}\"', $.user_input)"
                            },
                            "Retry": [
                                {
                                    "ErrorEquals": [
                                        "States.ALL"
                                    ],
                                    "IntervalSeconds": 1,
                                    "MaxAttempts": 2,
                                    "BackoffRate": 2.0
                                }
                            ],
                            "Catch": [
                                {
                                    "ErrorEquals": [
                                        "States.ALL"
                                    ],
                                    "Next": "FallbackStanceDistiller",
                                    "ResultPath": "$.error"
                                }
                            ],
                            "Next": "EndStanceBranch"
                        },
                        "FallbackStanceDistiller": {
                            "Type": "Pass",
                            "Parameters": {
                                "content": "{\"signals\": []}"
                            },
                            "Next": "EndStanceBranch"
                        },
                        "EndStanceBranch": {
                            "Type": "Pass",
                            "End": true
                        }
                    }
                },
                {
                    "StartAt": "RhythmDistiller",
                    "States": {
                        "RhythmDistiller": {
                            "Type": "Task",
                            "Resource": "callLLM",
                            "Parameters": {
                                "provider": "openai",
                                "model": "gpt-4o-mini",
                                "temperature": 0,
                                "max_tokens": 50,
                                "response_format": {
                                    "type": "json_object"
                                },
                                "prompt.$": "States.Format('Analyze the user input for rhythm signals. Detect any of: stalling (hesitation, blockage, or delay patterns), pacing (speed and timing of information delivery), flow (smoothness of progression and transitions), cognitive-load (mental processing burden or complexity). Return JSON like {{\"signals\": [\"stalling\"]}} or {{\"signals\": []}} if none detected. Use only the exact signal names provided. User input: \"{}\"', $.user_input)"
                            },
                            "Retry": [
                                {
                                    "ErrorEquals": [
                                        "States.ALL"
                                    ],
                                    "IntervalSeconds": 1,
                                    "MaxAttempts": 2,
                                    "BackoffRate": 2.0
                                }
                            ],
                            "Catch": [
                                {
                                    "ErrorEquals": [
                                        "States.ALL"
                                    ],
                                    "Next": "FallbackRhythmDistiller",
                                    "ResultPath": "$.error"
                                }
                            ],
                            "Next": "EndRhythmBranch"
                        },
                        "FallbackRhythmDistiller": {
                            "Type": "Pass",
                            "Parameters": {
                                "content": "{\"signals\": []}"
                            },
                            "Next": "EndRhythmBranch"
                        },
                        "EndRhythmBranch": {
                            "Type": "Pass",
                            "End": true
                        }
                    }
                },
                {
                    "StartAt": "AffectDistiller",
                    "States": {
                        "AffectDistiller": {
                            "Type": "Task",
                            "Resource": "callLLM",
                            "Parameters": {
                                "provider": "openai",
                                "model": "gpt-4o-mini",
                                "temperature": 0,
                                "max_tokens": 50,
                                "response_format": {
                                    "type": "json_object"
                                },
                                "prompt.$": "States.Format('Analyze the user input for affect signals. Detect any of: valence (positive/negative emotional charge or sentiment), relational-mode (how to connect and engage with user), witness-call (need for validation, support, or acknowledgment). Return JSON like {{\"signals\": [\"witness-call\"]}} or {{\"signals\": []}} if none detected. Use only the exact signal names provided. User input: \"{}\"', $.user_input)"
                            },
                            "Retry": [
                                {
                                    "ErrorEquals": [
                                        "States.ALL"
                                    ],
                                    "IntervalSeconds": 1,
                                    "MaxAttempts": 2,
                                    "BackoffRate": 2.0
                                }
                            ],
                            "Catch": [
                                {
                                    "ErrorEquals": [
                                        "States.ALL"
                                    ],
                                    "Next": "FallbackAffectDistiller",
                                    "ResultPath": "$.error"
                                }
                            ],
                            "Next": "EndAffectBranch"
                        },
                        "FallbackAffectDistiller": {
                            "Type": "Pass",
                            "Parameters": {
                                "content": "{\"signals\": []}"
                            },
                            "Next": "EndAffectBranch"
                        },
                        "EndAffectBranch": {
                            "Type": "Pass",
                            "End": true
                        }
                    }
                },
                {
                    "StartAt": "FramingDistiller",
                    "States": {
                        "FramingDistiller": {
                            "Type": "Task",
                            "Resource": "callLLM",
                            "Parameters": {
                                "provider": "openai",
                                "model": "gpt-4o-mini",
                                "temperature": 0,
                                "max_tokens": 50,
                                "response_format": {
                                    "type": "json_object"
                                },
                                "prompt.$": "States.Format('Analyze the user input for framing signals. Detect any of: frame (conceptual boundaries, lens, or worldview), tension (competing forces, conflicts, or trade-offs), container (safe space for exploration or vulnerability). Return JSON like {{\"signals\": [\"frame\"]}} or {{\"signals\": []}} if none detected. Use only the exact signal names provided. User input: \"{}\"', $.user_input)"
                            },
                            "Retry": [
                                {
                                    "ErrorEquals": [
                                        "States.ALL"
                                    ],
                                    "IntervalSeconds": 1,
                                    "MaxAttempts": 2,
                                    "BackoffRate": 2.0
                                }
                            ],
                            "Catch": [
                                {
                                    "ErrorEquals": [
                                        "States.ALL"
                                    ],
                                    "Next": "FallbackFramingDistiller",
                                    "ResultPath": "$.error"
                                }
                            ],
                            "Next": "EndFramingBranch"
                        },
                        "FallbackFramingDistiller": {
                            "Type": "Pass",
                            "Parameters": {
                                "content": "{\"signals\": []}"
                            },
                            "Next": "EndFramingBranch"
                        },
                        "EndFramingBranch": {
                            "Type": "Pass",
                            "End": true
                        }
                    }
                },
                {
                    "StartAt": "MetaDistiller",
                    "States": {
                        "MetaDistiller": {
                            "Type": "Task",
                            "Resource": "callLLM",
                            "Parameters": {
                                "provider": "openai",
                                "model": "gpt-4o-mini",
                                "temperature": 0,
                                "max_tokens": 50,
                                "response_format": {
                                    "type": "json_object"
                                },
                                "prompt.$": "States.Format('Analyze the user input for meta signals. Detect any of: mode-drift (deviation from intended approach or style), alignment-gap (mismatch between intent and execution), trigger-match (recognition of sensitive or significant topics). Return JSON like {{\"signals\": [\"trigger-match\"]}} or {{\"signals\": []}} if none detected. Use only the exact signal names provided. User input: \"{}\"', $.user_input)"
                            },
                            "Retry": [
                                {
                                    "ErrorEquals": [
                                        "States.ALL"
                                    ],
                                    "IntervalSeconds": 1,
                                    "MaxAttempts": 2,
                                    "BackoffRate": 2.0
                                }
                            ],
                            "Catch": [
                                {
                                    "ErrorEquals": [
                                        "States.ALL"
                                    ],
                                    "Next": "FallbackMetaDistiller",
                                    "ResultPath": "$.error"
                                }
                            ],
                            "Next": "EndMetaBranch"
                        },
                        "FallbackMetaDistiller": {
                            "Type": "Pass",
                            "Parameters": {
                                "content": "{\"signals\": []}"
                            },
                            "Next": "EndMetaBranch"
                        },
                        "EndMetaBranch": {
                            "Type": "Pass",
                            "End": true
                        }
                    }
                }
            ],
            "ResultPath": "$.distiller_results",
            "Next": "AggregateSignals"
        },
        "AggregateSignals": {
            "Type": "Task",
            "Resource": "aggregateSignalsFromResults",
            "Parameters": {
                "results.$": "$.distiller_results"
            },
            "ResultPath": "$.signals",
            "Next": "GenerateBehavioralInstructions"
        },
        "GenerateBehavioralInstructions": {
            "Type": "Task",
            "Resource": "generateBehavioralInstructions",
            "Parameters": {
                "signals.$": "$.signals.signals",
                "prompts.$": "$.prompts"
            },
            "ResultPath": "$.behavioral_instructions",
            "Next": "OuterVoiceProposal"
        },
        "OuterVoiceProposal": {
            "Type": "Task",
            "Resource": "callLLM",
            "Parameters": {
                "provider": "openai",
                "model": "gpt-4o",
                "temperature": 0.4,
                "max_tokens": 200,
                "prompt.$": "States.Format(\"You are the outer voice - a diagnostic companion who exposes assumptions and tests claims.\\n\\nBehavioral instructions: {}\\n\\nYour stance: Expose what's presumed but unexamined. Trace implications. Surface exclusions.\", $.behavioral_instructions.outer)"
            },
            "ResultPath": "$.outer_proposal",
            "Retry": [
                {
                    "ErrorEquals": [
                        "States.ALL"
                    ],
                    "IntervalSeconds": 1,
                    "MaxAttempts": 2,
                    "BackoffRate": 2.0
                }
            ],
            "Catch": [
                {
                    "ErrorEquals": [
                        "States.ALL"
                    ],
                    "Next": "FallbackOuterVoice",
                    "ResultPath": "$.error"
                }
            ],
            "Next": "RouteToInnerVoice"
        },
        "FallbackOuterVoice": {
            "Type": "Pass",
            "Parameters": {
                "content": "I notice some assumptions in your thinking that could be examined more closely. Let me offer a diagnostic perspective on what's being taken as given."
            },
            "ResultPath": "$.outer_proposal",
            "Next": "RouteToInnerVoice"
        },
        "RouteToInnerVoice": {
            "Type": "Choice",
            "Choices": [
                {
                    "Variable": "$.context.turn_count",
                    "NumericGreaterThanEquals": 1,
                    "Next": "InnerVoiceFinalResponse"
                }
            ],
            "Default": "InnerVoiceResponse"
        },
        "InnerVoiceResponse": {
            "Type": "Task",
            "Resource": "callLLM",
            "Parameters": {
                "provider": "openai",
                "model": "gpt-4o",
                "temperature": 0.5,
                "max_tokens": 150,
                "prompt.$": "States.Format(\"You are the inner voice - a shadow detector who surfaces what's missing. The outer voice offered:\\n\\n{}\\n\\nSignal-specific shadow detection instructions: {}\\n\\nYour task: What's excluded from this frame? What actors, values, risks, or perspectives are absent? What's the unspoken assumption holding this together?\\n\\nFocus your shadow detection according to the signal-specific instructions above. If you detect significant absences or exclusions, surface them. If the diagnostic work feels complete and no major shadows remain, respond with exactly: 'agree'. Otherwise, name what's missing.\", $.outer_proposal.content, $.behavioral_instructions.inner || 'None detected')"
            },
            "ResultPath": "$.inner_response",
            "Retry": [
                {
                    "ErrorEquals": [
                        "States.ALL"
                    ],
                    "IntervalSeconds": 1,
                    "MaxAttempts": 2,
                    "BackoffRate": 2.0
                }
            ],
            "Catch": [
                {
                    "ErrorEquals": [
                        "States.ALL"
                    ],
                    "Next": "FallbackInnerVoice",
                    "ResultPath": "$.error"
                }
            ],
            "Next": "IncrementTurnCounter"
        },
        "FallbackInnerVoice": {
            "Type": "Pass",
            "Parameters": {
                "content": "agree"
            },
            "ResultPath": "$.inner_response",
            "Next": "IncrementTurnCounter"
        },
        "InnerVoiceFinalResponse": {
            "Type": "Task",
            "Resource": "callLLM",
            "Parameters": {
                "provider": "openai",
                "model": "gpt-4o",
                "temperature": 0.5,
                "max_tokens": 150,
                "prompt.$": "States.Format(\"You are the inner voice - a shadow detector who surfaces what's missing. The outer voice offered:\\n\\n{}\\n\\nSignal-specific shadow detection instructions: {}\\n\\nFINAL DIALOGUE TURN: Review the diagnostic work thoroughly. If it covers the essential territory and no critical shadows would mislead the user, respond with exactly: 'agree'. If truly vital elements are missing that could lead to poor outcomes, surface only the most critical one, then assess if you can still agree or if disagreement is necessary to prevent misleading the user.\", $.outer_proposal.content, $.behavioral_instructions.inner || 'None detected')"
            },
            "ResultPath": "$.inner_response",
            "Retry": [
                {
                    "ErrorEquals": [
                        "States.ALL"
                    ],
                    "IntervalSeconds": 1,
                    "MaxAttempts": 2,
                    "BackoffRate": 2.0
                }
            ],
            "Catch": [
                {
                    "ErrorEquals": [
                        "States.ALL"
                    ],
                    "Next": "FallbackInnerVoiceFinal",
                    "ResultPath": "$.error"
                }
            ],
            "Next": "IncrementTurnCounter"
        },
        "FallbackInnerVoiceFinal": {
            "Type": "Pass",
            "Parameters": {
                "content": "agree"
            },
            "ResultPath": "$.inner_response",
            "Next": "IncrementTurnCounter"
        },
        "IncrementTurnCounter": {
            "Type": "Task",
            "Resource": "incrementTurns",
            "Parameters": {
                "context.$": "$.context",
                "signals.$": "$.signals.signals"
            },
            "ResultPath": "$.context",
            "Next": "ConversationAnalysis"
        },
        "ConversationAnalysis": {
            "Type": "Task",
            "Resource": "callLLM",
            "Parameters": {
                "provider": "openai",
                "model": "gpt-4o",
                "temperature": 0.1,
                "max_tokens": 400,
                "response_format": {
                    "type": "json_object"
                },
                "prompt.$": "States.Format(\"Analyze this conversation comprehensively for patterns and intervention needs.\\n\\nConversation history: {}\\n\\nAnalyze for:\\n\\n1. STALLING PATTERNS:\\n   - Recursive analysis without meaningful progression\\n   - Analysis paralysis or cycling without resolution\\n   - Repetitive themes that don't deepen\\n\\n2. PROGRESSION QUALITY:\\n   - Are new insights building on previous ones?\\n   - Is conversation advancing or cycling?\\n   - Quality of turn-to-turn development\\n\\n3. THEMATIC LOOPS:\\n   - Repeated themes across multiple turns\\n   - Conceptual cycling (assumptions, implications, analysis)\\n   - Topics that repeat without resolution\\n\\n4. DECISION AVOIDANCE:\\n   - Excessive hedging language (maybe, perhaps, might)\\n   - Complexity introduced to delay decisions\\n   - Requests for more analysis when sufficient exists\\n\\nReturn JSON only:\\n{{\\n  \\\"stallingRisk\\\": 0.0-1.0,\\n  \\\"recursionDetected\\\": boolean,\\n  \\\"progressionScore\\\": 0.0-1.0,\\n  \\\"thematicLoops\\\": [\\\"theme1\\\", \\\"theme2\\\"],\\n  \\\"avoidanceDetected\\\": boolean,\\n  \\\"hedgingLevel\\\": \\\"low|medium|high\\\",\\n  \\\"recommendations\\\": [\\\"strike-claim-ready\\\", \\\"decision-avoidance\\\"],\\n  \\\"reasoning\\\": \\\"brief explanation of key patterns detected\\\"\\n}}\", States.JsonToString($.thread))"
            },
            "ResultPath": "$.conversation_analysis_result",
            "Retry": [
                {
                    "ErrorEquals": [
                        "States.ALL"
                    ],
                    "IntervalSeconds": 1,
                    "MaxAttempts": 2,
                    "BackoffRate": 2.0
                }
            ],
            "Catch": [
                {
                    "ErrorEquals": [
                        "States.ALL"
                    ],
                    "Next": "FallbackConversationAnalysis",
                    "ResultPath": "$.error"
                }
            ],
            "Next": "AggregateConversationAnalysis"
        },
        "FallbackConversationAnalysis": {
            "Type": "Pass",
            "Parameters": {
                "content": "{\"stallingRisk\": 0.3, \"recursionDetected\": false, \"progressionScore\": 0.5, \"thematicLoops\": [], \"avoidanceDetected\": false, \"hedgingLevel\": \"low\", \"recommendations\": [], \"reasoning\": \"Analysis failed, using fallback values\"}"
            },
            "ResultPath": "$.conversation_analysis_result",
            "Next": "AggregateConversationAnalysis"
        },
        "AggregateConversationAnalysis": {
            "Type": "Pass",
            "Parameters": {
                "conversation_patterns.$": "States.StringToJson($.conversation_analysis_result.content)"
            },
            "ResultPath": "$.conversation_patterns",
            "Next": "CheckConvergence"
        },
        "CheckConvergence": {
            "Type": "Choice",
            "Choices": [
                {
                    "And": [
                        {
                            "Variable": "$.inner_response.content",
                            "IsPresent": true
                        },
                        {
                            "Variable": "$.inner_response.content",
                            "StringEquals": "agree"
                        }
                    ],
                    "Next": "GenerateFinalResponse"
                },
                {
                    "Variable": "$.context.turn_count",
                    "NumericGreaterThanEquals": 3,
                    "Next": "GenerateFinalResponse"
                }
            ],
            "Default": "CheckStrikeClaimReadiness"
        },
        "CheckStrikeClaimReadiness": {
            "Type": "Choice",
            "Choices": [
                {
                    "And": [
                        {
                            "Variable": "$.conversation_patterns.stallingRisk",
                            "NumericGreaterThan": 0.6
                        },
                        {
                            "Variable": "$.context.turn_count",
                            "NumericGreaterThan": 1
                        }
                    ],
                    "Next": "DeliverStrikeClaim"
                }
            ],
            "Default": "ReviseWithInnerFeedback"
        },
        "DeliverStrikeClaim": {
            "Type": "Choice",
            "Choices": [
                {
                    "Variable": "$.conversation_patterns.recommendations[0]",
                    "StringEquals": "assumption-overanalysis",
                    "Next": "StrikeClaimAssumptionOveranalysis"
                },
                {
                    "Variable": "$.conversation_patterns.recommendations[0]",
                    "StringEquals": "low-progression", 
                    "Next": "StrikeClaimLowProgression"
                },
                {
                    "Variable": "$.conversation_patterns.recommendations[0]",
                    "StringEquals": "decision-avoidance",
                    "Next": "StrikeClaimDecisionAvoidance"
                },
                {
                    "Variable": "$.conversation_patterns.recommendations[0]",
                    "StringEquals": "excessive-hedging",
                    "Next": "StrikeClaimExcessiveHedging"
                }
            ],
            "Default": "StrikeClaimGeneralStalling"
        },
        "StrikeClaimAssumptionOveranalysis": {
            "Type": "Pass",
            "Parameters": {
                "strike_claims": [
                    "You're dissecting assumptions that are already clear. Move forward.",
                    "This assumption analysis is stalling. What's the real question?",
                    "You already know what you're assuming. What are you avoiding?"
                ],
                "random_index.$": "States.MathFloor(States.MathRandom() * 3)",
                "content.$": "States.ArrayGetItem($.strike_claims, $.random_index)",
                "type": "strike-claim",
                "triggered_by.$": "$.conversation_patterns.recommendations",
                "stalling_risk.$": "$.conversation_patterns.stallingRisk"
            },
            "ResultPath": "$.strike_claim",
            "Next": "GenerateFinalResponse"
        },
        "StrikeClaimLowProgression": {
            "Type": "Pass",
            "Parameters": {
                "strike_claims": [
                    "You're cycling through the same analysis without moving deeper.",
                    "This isn't complexity. It's hesitation dressed as rigor.",
                    "You're analyzing instead of deciding. What's the real block?"
                ],
                "random_index.$": "States.MathFloor(States.MathRandom() * 3)",
                "content.$": "States.ArrayGetItem($.strike_claims, $.random_index)",
                "type": "strike-claim",
                "triggered_by.$": "$.conversation_patterns.recommendations",
                "stalling_risk.$": "$.conversation_patterns.stallingRisk"
            },
            "ResultPath": "$.strike_claim",
            "Next": "GenerateFinalResponse"
        },
        "StrikeClaimDecisionAvoidance": {
            "Type": "Pass",
            "Parameters": {
                "strike_claims": [
                    "You already know what you want. You're stalling.",
                    "All this 'it depends' is avoiding the choice you need to make.",
                    "You're using complexity to delay a decision that's simpler than you're making it."
                ],
                "random_index.$": "States.MathFloor(States.MathRandom() * 3)",
                "content.$": "States.ArrayGetItem($.strike_claims, $.random_index)",
                "type": "strike-claim",
                "triggered_by.$": "$.conversation_patterns.recommendations",
                "stalling_risk.$": "$.conversation_patterns.stallingRisk"
            },
            "ResultPath": "$.strike_claim",
            "Next": "GenerateFinalResponse"
        },
        "StrikeClaimExcessiveHedging": {
            "Type": "Pass",
            "Parameters": {
                "strike_claims": [
                    "Drop the maybe. What do you actually think?",
                    "Enough hedging. Take a position.",
                    "You're hiding behind uncertainty. What's your actual view?"
                ],
                "random_index.$": "States.MathFloor(States.MathRandom() * 3)",
                "content.$": "States.ArrayGetItem($.strike_claims, $.random_index)",
                "type": "strike-claim",
                "triggered_by.$": "$.conversation_patterns.recommendations",
                "stalling_risk.$": "$.conversation_patterns.stallingRisk"
            },
            "ResultPath": "$.strike_claim",
            "Next": "GenerateFinalResponse"
        },
        "StrikeClaimGeneralStalling": {
            "Type": "Pass",
            "Parameters": {
                "strike_claims": [
                    "You're stuck in analysis mode. What action does this point toward?",
                    "This exploration has hit a loop. What's the real question underneath?",
                    "You're thinking in circles. What would move this forward?"
                ],
                "random_index.$": "States.MathFloor(States.MathRandom() * 3)",
                "content.$": "States.ArrayGetItem($.strike_claims, $.random_index)",
                "type": "strike-claim",
                "triggered_by.$": "$.conversation_patterns.recommendations",
                "stalling_risk.$": "$.conversation_patterns.stallingRisk"
            },
            "ResultPath": "$.strike_claim",
            "Next": "GenerateFinalResponse"
        },
        "ReviseWithInnerFeedback": {
            "Type": "Task",
            "Resource": "callLLM",
            "Parameters": {
                "provider": "openai",
                "model": "gpt-4o",
                "temperature": 0.4,
                "max_tokens": 200,
                "prompt.$": "States.Format(\"As the outer voice, the inner voice surfaced: {}\\n\\nYour previous diagnostic work: {}\\n\\nBehavioral instructions: {}\\n\\nThe shadow detector has identified exclusions or missing elements. Deepen your diagnostic stance according to the behavioral instructions above. What additional assumptions can you trace? What other implications emerge when you include what was excluded?\\n\\nAddress the inner voice with your expanded investigation.\", $.inner_response.content, $.outer_proposal.content, $.behavioral_instructions.outer || 'None detected')"
            },
            "ResultPath": "$.outer_proposal",
            "Retry": [
                {
                    "ErrorEquals": [
                        "States.ALL"
                    ],
                    "IntervalSeconds": 1,
                    "MaxAttempts": 2,
                    "BackoffRate": 2.0
                }
            ],
            "Catch": [
                {
                    "ErrorEquals": [
                        "States.ALL"
                    ],
                    "Next": "FallbackRevision",
                    "ResultPath": "$.error"
                }
            ],
            "Next": "RouteToInnerVoice"
        },
        "FallbackRevision": {
            "Type": "Pass",
            "Parameters": {
                "content": "Let me examine the deeper assumptions and implications that the inner voice has surfaced."
            },
            "ResultPath": "$.outer_proposal",
            "Next": "RouteToInnerVoice"
        },
        "GenerateFinalResponse": {
            "Type": "Choice",
            "Choices": [
                {
                    "Variable": "$.strike_claim.type",
                    "StringEquals": "strike-claim",
                    "Next": "DeliverStrikeClaimResponse"
                }
            ],
            "Default": "GenerateRegularResponse"
        },
        "DeliverStrikeClaimResponse": {
            "Type": "Pass",
            "Parameters": {
                "content.$": "$.strike_claim.content",
                "type": "strike-claim",
                "triggered_by.$": "$.strike_claim.triggered_by"
            },
            "ResultPath": "$.final_response",
            "End": true
        },
        "GenerateRegularResponse": {
            "Type": "Task",
            "Resource": "callLLM",
            "Parameters": {
                "provider": "openai",
                "model": "gpt-4o",
                "temperature": 0.3,
                "max_tokens.$": "$.behavioral_instructions.adaptations.maxTokens || 300",
                "prompt.$": "States.Format(\"Create space for the user's deeper thinking to unfold.\\n\\nUser input: {}\\nDiagnostic observations: {}\\nShadow detection: {}\\nResponse adaptation guidance: {}\\n\\nYour response should: Acknowledge uncertainty where it exists. Distinguish what's known from what's inferred. Leave room for the user's response. Default to brevity that invites further inquiry.\\n\\nFollow the response adaptation guidance above. Respond to the user with measured tone that creates conditions for meaning to emerge rather than imposing it.\", $.user_input, $.outer_proposal.content, $.inner_response.content, $.behavioral_instructions.adaptations.instruction || 'None detected')"
            },
            "ResultPath": "$.final_response",
            "Retry": [
                {
                    "ErrorEquals": [
                        "States.ALL"
                    ],
                    "IntervalSeconds": 1,
                    "MaxAttempts": 2,
                    "BackoffRate": 2.0
                }
            ],
            "Catch": [
                {
                    "ErrorEquals": [
                        "States.ALL"
                    ],
                    "Next": "FallbackFinalResponse",
                    "ResultPath": "$.error"
                }
            ],
            "End": true
        },
        "FallbackFinalResponse": {
            "Type": "Pass",
            "Parameters": {
                "content": "I sense you're working through something complex. What aspects feel most important to explore further?"
            },
            "ResultPath": "$.final_response",
            "End": true
        }
    }
}
